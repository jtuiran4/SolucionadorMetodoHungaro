<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solucionador M√©todo H√∫ngaro</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2196F3, #21CBF3);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        .matrix-container {
            margin: 20px 0;
        }

        .matrix-input {
            display: grid;
            gap: 10px;
            max-width: fit-content;
            margin: 0 auto;
        }

        .matrix-input input {
            width: 80px;
            text-align: center;
            font-weight: 600;
        }

        button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            margin: 10px 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .solve-btn {
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .solve-btn:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .results {
            margin-top: 30px;
        }

        .step {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 5px solid #2196F3;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .step h3 {
            color: #2196F3;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #e3f2fd;
            padding-bottom: 10px;
        }

        .matrix-display {
            overflow-x: auto;
            margin: 15px 0;
        }

        table {
            border-collapse: collapse;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #ddd;
            font-weight: 600;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 1.1em;
        }

        .highlighted {
            background-color: #ffeb3b !important;
            color: #333;
            font-weight: bold;
        }

        .assigned {
            background-color: #4caf50 !important;
            color: white;
            font-weight: bold;
        }

        .crossed {
            background-color: #f44336 !important;
            color: white;
            text-decoration: line-through;
        }

        .cost-summary {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .example-buttons {
            text-align: center;
            margin: 20px 0;
        }

        .example-btn {
            background: linear-gradient(135deg, #9C27B0, #E1BEE7);
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
        }

        .example-btn:hover {
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 5px solid #f44336;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 15px;
            }
            
            .matrix-input input {
                width: 60px;
            }
            
            th, td {
                padding: 8px 10px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¢ Solucionador M√©todo H√∫ngaro</h1>
            <p>Resuelve problemas de asignaci√≥n paso a paso</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <label for="problemType">Tipo de Problema:</label>
                    <select id="problemType">
                        <option value="minimization">Minimizaci√≥n</option>
                        <option value="maximization">Maximizaci√≥n</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="matrixSize">Tama√±o de la Matriz:</label>
                    <input type="number" id="matrixSize" min="2" max="6" value="3">
                    <button onclick="createMatrix()">Crear Matriz</button>
                </div>
                
                <div class="example-buttons">
                    <button class="example-btn" onclick="loadExample(1)">Ejemplo 1 (3x3)</button>
                    <button class="example-btn" onclick="loadExample(2)">Ejemplo 2 (4x4)</button>
                    <button class="example-btn" onclick="loadExample(3)">Ejemplo 3 (5x5)</button>
                </div>
                
                <div id="matrixContainer"></div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="solve-btn" onclick="solve()">üöÄ Resolver</button>
                </div>
            </div>
            
            <div id="results"></div>
        </div>
    </div>

    <script>
        let matrix = [];
        let steps = [];

        function createMatrix() {
            const size = parseInt(document.getElementById('matrixSize').value);
            const container = document.getElementById('matrixContainer');
            
            container.innerHTML = `
                <div class="matrix-container">
                    <h3>Matriz de Costos:</h3>
                    <div class="matrix-input" id="matrixInput"></div>
                </div>
            `;
            
            const matrixInput = document.getElementById('matrixInput');
            matrixInput.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = `cell_${i}_${j}`;
                    input.placeholder = '0';
                    input.value = '0';
                    matrixInput.appendChild(input);
                }
            }
        }

        function loadExample(exampleNum) {
            if (exampleNum === 1) {
                document.getElementById('matrixSize').value = 3;
                createMatrix();
                const example1 = [[4, 2, 8], [4, 3, 7], [1, 2, 5]];
                loadMatrixValues(example1);
            } else if (exampleNum === 2) {
                document.getElementById('matrixSize').value = 4;
                createMatrix();
                const example2 = [[10, 2, 8, 6], [9, 4, 7, 8], [7, 6, 5, 2], [8, 1, 4, 9]];
                loadMatrixValues(example2);
            } else if (exampleNum === 3) {
                document.getElementById('matrixSize').value = 5;
                createMatrix();
                const example3 = [[12, 7, 9, 7, 9], [8, 9, 6, 6, 6], [7, 17, 12, 14, 6], [15, 13, 6, 6, 10], [4, 15, 4, 12, 8]];
                loadMatrixValues(example3);
            }
        }

        function loadMatrixValues(values) {
            for (let i = 0; i < values.length; i++) {
                for (let j = 0; j < values[i].length; j++) {
                    document.getElementById(`cell_${i}_${j}`).value = values[i][j];
                }
            }
        }

        function getMatrix() {
            const size = parseInt(document.getElementById('matrixSize').value);
            const matrix = [];
            
            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size; j++) {
                    const value = parseFloat(document.getElementById(`cell_${i}_${j}`).value) || 0;
                    matrix[i][j] = value;
                }
            }
            
            return matrix;
        }

        function solve() {
            try {
                matrix = getMatrix();
                const problemType = document.getElementById('problemType').value;
                
                steps = [];
                
                // Para maximizaci√≥n, convertir a minimizaci√≥n
                let workingMatrix = matrix.map(row => [...row]);
                if (problemType === 'maximization') {
                    const maxValue = Math.max(...matrix.flat());
                    workingMatrix = matrix.map(row => row.map(val => maxValue - val));
                    
                    steps.push({
                        title: "Paso 0: Conversi√≥n para Maximizaci√≥n",
                        description: `Convertimos el problema de maximizaci√≥n a minimizaci√≥n restando cada elemento del valor m√°ximo (${maxValue}).`,
                        matrix: workingMatrix,
                        type: 'conversion'
                    });
                }
                
                // Paso 1: Restar el m√≠nimo de cada fila
                const step1Matrix = subtractRowMinimums(workingMatrix);
                
                // Paso 2: Restar el m√≠nimo de cada columna
                const step2Matrix = subtractColumnMinimums(step1Matrix);
                
                // Paso 3: Encontrar asignaci√≥n √≥ptima
                const solution = findOptimalAssignment(step2Matrix);
                
                displayResults(solution, problemType);
                
            } catch (error) {
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <strong>Error:</strong> ${error.message}
                    </div>
                `;
            }
        }

        function subtractRowMinimums(matrix) {
            const newMatrix = matrix.map(row => [...row]);
            const size = matrix.length;
            
            for (let i = 0; i < size; i++) {
                const rowMin = Math.min(...matrix[i]);
                for (let j = 0; j < size; j++) {
                    newMatrix[i][j] = matrix[i][j] - rowMin;
                }
            }
            
            steps.push({
                title: "Paso 1: Reducci√≥n por Filas",
                description: "Restamos el elemento m√≠nimo de cada fila a todos los elementos de esa fila.",
                matrix: newMatrix,
                type: 'row_reduction'
            });
            
            return newMatrix;
        }

        function subtractColumnMinimums(matrix) {
            const newMatrix = matrix.map(row => [...row]);
            const size = matrix.length;
            
            for (let j = 0; j < size; j++) {
                const colMin = Math.min(...matrix.map(row => row[j]));
                for (let i = 0; i < size; i++) {
                    newMatrix[i][j] = matrix[i][j] - colMin;
                }
            }
            
            steps.push({
                title: "Paso 2: Reducci√≥n por Columnas",
                description: "Restamos el elemento m√≠nimo de cada columna a todos los elementos de esa columna.",
                matrix: newMatrix,
                type: 'column_reduction'
            });
            
            return newMatrix;
        }

        function findOptimalAssignment(matrix) {
            const size = matrix.length;
            let workingMatrix = matrix.map(row => [...row]);
            let assignment = new Array(size).fill(-1);
            let iteration = 0;
            const maxIterations = 20;
            
            while (iteration < maxIterations) {
                iteration++;
                
                // Verificar si podemos hacer una asignaci√≥n completa
                const tempAssignment = hungarianAssignment(workingMatrix);
                const assignedCount = tempAssignment.filter(x => x !== -1).length;
                
                steps.push({
                    title: `Paso ${2 + iteration}: Verificaci√≥n de Asignaci√≥n`,
                    description: `Intentamos encontrar una asignaci√≥n completa. Asignaciones encontradas: ${assignedCount}/${size}`,
                    matrix: workingMatrix,
                    assignment: tempAssignment,
                    type: 'assignment_check'
                });
                
                if (assignedCount === size) {
                    // Asignaci√≥n completa encontrada
                    assignment = tempAssignment;
                    break;
                } else {
                    // Necesitamos mejorar la matriz
                    const coverage = findMinimumCoverage(workingMatrix);
                    
                    steps.push({
                        title: `Paso ${2 + iteration}b: Cobertura de Ceros`,
                        description: `Cubrimos todos los ceros con ${coverage.lines.length} l√≠neas. Necesitamos ${size} l√≠neas para una soluci√≥n √≥ptima.`,
                        matrix: workingMatrix,
                        coverage: coverage,
                        type: 'coverage_check'
                    });
                    
                    if (coverage.lines.length < size) {
                        // Aplicar el paso de mejora
                        workingMatrix = improveMatrix(workingMatrix, coverage);
                        
                        steps.push({
                            title: `Paso ${2 + iteration}c: Mejora de la Matriz`,
                            description: "Aplicamos el m√©todo de mejora: restamos el m√≠nimo no cubierto y lo sumamos a elementos doblemente cubiertos.",
                            matrix: workingMatrix,
                            type: 'improvement'
                        });
                    }
                }
            }
            
            if (assignment.filter(x => x !== -1).length < size) {
                throw new Error("No se pudo encontrar una asignaci√≥n completa despu√©s de " + maxIterations + " iteraciones");
            }
            
            const totalCost = calculateTotalCost(assignment);
            
            return {
                assignment: assignment,
                totalCost: totalCost,
                finalMatrix: workingMatrix
            };
        }

        function findMinimumCoverage(matrix) {
            const size = matrix.length;
            
            // Encontrar todas las posiciones de ceros
            const zeros = [];
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (matrix[i][j] === 0) {
                        zeros.push([i, j]);
                    }
                }
            }
            
            // Usar el teorema de K√∂nig para encontrar cobertura m√≠nima
            // Primero encontramos el matching m√°ximo
            const matching = findMaximumMatching(zeros, size);
            
            // El tama√±o de la cobertura m√≠nima = tama√±o del matching m√°ximo
            const matchedRows = new Set();
            const matchedCols = new Set();
            
            for (const [row, col] of matching) {
                matchedRows.add(row);
                matchedCols.add(col);
            }
            
            // Encontrar v√©rtices no matcheados en filas
            const unmatchedRows = [];
            for (let i = 0; i < size; i++) {
                if (!matchedRows.has(i)) {
                    unmatchedRows.push(i);
                }
            }
            
            // Construir grafo de ceros
            const graph = new Array(size).fill(null).map(() => []);
            for (const [i, j] of zeros) {
                graph[i].push(j);
            }
            
            // Encontrar v√©rtices alcanzables desde filas no matcheadas
            const reachableRows = new Set(unmatchedRows);
            const reachableCols = new Set();
            const visited = new Set();
            
            function dfsReachable(row) {
                if (visited.has('r' + row)) return;
                visited.add('r' + row);
                
                for (const col of graph[row]) {
                    if (!reachableCols.has(col)) {
                        reachableCols.add(col);
                        
                        // Encontrar la fila matcheada con esta columna
                        for (const [mRow, mCol] of matching) {
                            if (mCol === col && !reachableRows.has(mRow)) {
                                reachableRows.add(mRow);
                                dfsReachable(mRow);
                            }
                        }
                    }
                }
            }
            
            for (const row of unmatchedRows) {
                dfsReachable(row);
            }
            
            // La cobertura m√≠nima consiste en:
            // - Filas matcheadas NO alcanzables
            // - Columnas alcanzables
            const coveringRows = [];
            const coveringCols = [];
            const lines = [];
            
            for (let i = 0; i < size; i++) {
                if (matchedRows.has(i) && !reachableRows.has(i)) {
                    coveringRows.push(i);
                    lines.push({type: 'row', index: i});
                }
            }
            
            for (const col of reachableCols) {
                coveringCols.push(col);
                lines.push({type: 'col', index: col});
            }
            
            return {
                lines: lines,
                coveredRows: coveringRows,
                coveredCols: coveringCols
            };
        }

        function improveMatrix(matrix, coverage) {
            const size = matrix.length;
            const newMatrix = matrix.map(row => [...row]);
            
            // Encontrar el m√≠nimo elemento no cubierto
            let minUncovered = Infinity;
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (!coverage.coveredRows.includes(i) && !coverage.coveredCols.includes(j)) {
                        minUncovered = Math.min(minUncovered, matrix[i][j]);
                    }
                }
            }
            
            // Aplicar transformaci√≥n
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (!coverage.coveredRows.includes(i) && !coverage.coveredCols.includes(j)) {
                        // Elemento no cubierto: restar el m√≠nimo
                        newMatrix[i][j] = matrix[i][j] - minUncovered;
                    } else if (coverage.coveredRows.includes(i) && coverage.coveredCols.includes(j)) {
                        // Elemento doblemente cubierto: sumar el m√≠nimo
                        newMatrix[i][j] = matrix[i][j] + minUncovered;
                    }
                    // Elementos cubiertos una vez: no cambian
                }
            }
            
            return newMatrix;
        }

        function findAssignment(matrix) {
            const size = matrix.length;
            const assignment = new Array(size).fill(-1);
            
            // Implementaci√≥n del algoritmo h√∫ngaro para encontrar asignaci√≥n m√°xima
            const result = hungarianAssignment(matrix);
            
            return result;
        }
        
        function hungarianAssignment(matrix) {
            const size = matrix.length;
            const assignment = new Array(size).fill(-1);
            
            // Crear matriz de ceros para trabajar
            const zeros = [];
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (matrix[i][j] === 0) {
                        zeros.push([i, j]);
                    }
                }
            }
            
            // Usar algoritmo de matching bipartito
            const matching = findMaximumMatching(zeros, size);
            
            // Convertir matching a array de asignaci√≥n
            for (const [row, col] of matching) {
                assignment[row] = col;
            }
            
            return assignment;
        }
        
        function findMaximumMatching(zeros, size) {
            const graph = new Array(size).fill(null).map(() => []);
            
            // Construir grafo de ceros
            for (const [i, j] of zeros) {
                graph[i].push(j);
            }
            
            const matching = [];
            const usedCols = new Set();
            const visited = new Array(size);
            
            // Intento de asignaci√≥n usando DFS
            for (let row = 0; row < size; row++) {
                visited.fill(false);
                if (dfs(row, graph, matching, usedCols, visited, size)) {
                    // Se encontr√≥ una asignaci√≥n para esta fila
                }
            }
            
            return matching;
        }
        
        function dfs(row, graph, matching, usedCols, visited, size) {
            for (const col of graph[row]) {
                if (visited[col]) continue;
                visited[col] = true;
                
                // Si la columna est√° libre o podemos reasignar
                let currentRowForCol = -1;
                for (let i = 0; i < matching.length; i++) {
                    if (matching[i][1] === col) {
                        currentRowForCol = matching[i][0];
                        break;
                    }
                }
                
                if (currentRowForCol === -1) {
                    // Columna libre, asignar
                    matching.push([row, col]);
                    usedCols.add(col);
                    return true;
                } else if (dfs(currentRowForCol, graph, matching, usedCols, visited, size)) {
                    // Reasignar
                    for (let i = 0; i < matching.length; i++) {
                        if (matching[i][0] === currentRowForCol) {
                            matching[i] = [row, col];
                            break;
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function calculateTotalCost(assignment) {
            let total = 0;
            for (let i = 0; i < assignment.length; i++) {
                if (assignment[i] !== -1) {
                    total += matrix[i][assignment[i]];
                }
            }
            return total;
        }

        function displayResults(solution, problemType) {
            const resultsDiv = document.getElementById('results');
            let html = '<div class="results">';
            
            // Mostrar todos los pasos
            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                html += `
                    <div class="step">
                        <h3>${step.title}</h3>
                        <p>${step.description}</p>
                        <div class="matrix-display">
                            ${createTableHTML(step.matrix, step.type, step.coverage, step.assignment)}
                        </div>
                    </div>
                `;
            }
            
            // Mostrar soluci√≥n final
            html += `
                <div class="step">
                    <h3>Soluci√≥n √ìptima</h3>
                    <p>Asignaci√≥n encontrada:</p>
                    <div class="matrix-display">
                        ${createSolutionTableHTML(solution.assignment)}
                    </div>
                </div>
                
                <div class="cost-summary">
                    <div>üí∞ Costo Total ${problemType === 'maximization' ? '(Beneficio)' : ''}: ${solution.totalCost}</div>
                </div>
            `;
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        function createTableHTML(matrix, type = '', coverage = null, assignment = null) {
            const size = matrix.length;
            let html = '<table>';
            
            // Encabezados
            html += '<tr><th></th>';
            for (let j = 0; j < size; j++) {
                html += `<th>C${j + 1}</th>`;
            }
            html += '</tr>';
            
            // Filas de datos
            for (let i = 0; i < size; i++) {
                html += `<tr><th>F${i + 1}</th>`;
                for (let j = 0; j < size; j++) {
                    let cellClass = '';
                    let cellValue = matrix[i][j];
                    
                    // Mostrar asignaciones si est√°n disponibles
                    if (type === 'assignment_check' && assignment && assignment[i] === j) {
                        cellClass += ' assigned';
                        cellValue += ' ‚úì';
                    }
                    
                    if (type === 'coverage_check' && coverage) {
                        if (coverage.coveredRows.includes(i) || coverage.coveredCols.includes(j)) {
                            cellClass += ' crossed';
                        }
                    }
                    
                    if (matrix[i][j] === 0 && !cellClass.includes('assigned')) {
                        cellClass += ' highlighted';
                    }
                    
                    html += `<td class="${cellClass}">${cellValue}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</table>';
            return html;
        }

        function createSolutionTableHTML(assignment) {
            const size = assignment.length;
            let html = '<table>';
            
            // Encabezados
            html += '<tr><th></th>';
            for (let j = 0; j < size; j++) {
                html += `<th>C${j + 1}</th>`;
            }
            html += '</tr>';
            
            // Filas de datos
            for (let i = 0; i < size; i++) {
                html += `<tr><th>F${i + 1}</th>`;
                for (let j = 0; j < size; j++) {
                    let cellClass = '';
                    let cellValue = matrix[i][j];
                    
                    if (assignment[i] === j) {
                        cellClass = 'assigned';
                        cellValue += ' ‚úì';
                    }
                    
                    html += `<td class="${cellClass}">${cellValue}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</table>';
            
            // Agregar descripci√≥n de la asignaci√≥n
            html += '<div style="margin-top: 15px;"><strong>Asignaci√≥n:</strong><br>';
            for (let i = 0; i < assignment.length; i++) {
                if (assignment[i] !== -1) {
                    html += `Fila ${i + 1} ‚Üí Columna ${assignment[i] + 1} (Costo: ${matrix[i][assignment[i]]})<br>`;
                }
            }
            html += '</div>';
            
            return html;
        }

        // Inicializar con matriz 3x3
        window.onload = function() {
            createMatrix();
        };
    </script>
</body>
</html>